 /* Auto generated by grammer package
 * At 2018-07-19T13:15:27+09:00 
*/
Expr ::= (ExprSingle ("," ExprSingle)*)
SimpleLetClause ::= ("let" SimpleLetBinding ("," SimpleLetBinding)*)
IfExpr ::= ("if" "(" Expr ")" "then" ExprSingle "else" ExprSingle)
AbbrevForwardStep ::= ("@"? NodeTest)
PostfixExpr ::= (PrimaryExpr (Predicate | ArgumentList | Lookup)*)
ArgumentList ::= ("(" (Argument ("," Argument)*)? ")")
XPath ::= Expr
RangeExpr ::= (AdditiveExpr | ("to" AdditiveExpr)?)
PathExpr ::= (("/" RelativePathExpr?) | ("//" RelativePathExpr) | RelativePathExpr)
KeySpecifier ::= (NCName | IntegerLiteral | ParenthesizedExpr | "*")
ContextItemExpr ::= "."
InlineFunctionExpr ::= ("function" "(" ParamList? ")" ("as" SequenceType)? FunctionBody)
MapKeyExpr ::= ExprSingle
CurlyArrayConstructor ::= ("array" EnclosedExpr)
PrefixedName ::= (Prefix ":" LocalPart)
NCName ::= Name - (Char* ":" Char*)
RelativePathExpr ::= (StepExpr (("/" | "//") RelativePathExpr)*)
AbbrevReverseStep ::= ".."
NameTest ::= (EQName | Wildcard)
ArrowFunctionSpecifier ::= (EQName | VarRef | ParenthesizedExpr)
FunctionItemExpr ::= (NamedFunctionRef | InlineFunctionExpr)
UnaryLookup ::= ("?" KeySpecifier)
DoubleLiteral ::= ((("." Digits) | (Digits ("." [0-9]*)?)) [eE] [+-]? Digits)
StringLiteral ::= (("\"" (EscapeQuot | [^"])* "\"") | ("'" (EscapeApos | [^'])* "'"))
URIQualifiedName ::= (BracedURILiteral NCName)
QName ::= (PrefixedName | UnprefixedName)
ParamList ::= (Param ("," Param)*)
IntersectExceptExpr ::= (InstanceofExpr | (("intersect" | "except") InstanceofExpr)*)
ValueExpr ::= SimpleMapExpr
NodeTest ::= (KindTest | NameTest)
PredicateList ::= Predicate*
Literal ::= (NumericLiteral | StringLiteral)
NamedFunctionRef ::= (EQName "#" IntegerLiteral)
ExprSingle ::= (ForExpr | LetExpr | QuantifiedExpr | IfExpr | OrExpr)
Char ::= (	 | 
 | [ -퟿] | [-�] | [Ā00-ჿFF])
Param ::= ("$" EQName TypeDeclaration?)
AndExpr ::= (ComparisonExpr | ("and" ComparisonExpr)*)
ParenthesizedExpr ::= ("(" Expr? ")")
BracedURILiteral ::= ("Q" "{" [^{}]* "}")
NameStartChar ::= (":" | [A-Z] | "_" | [a-z] | [À-Ö] | [Ø-ö] | [ø-˿] | [Ͱ-ͽ] | [Ϳ-῿] | [‌-‍] | [⁰-↏] | [Ⰰ-⿯] | [、-퟿] | [豈-﷏] | [ﷰ-�] | [Ā00-໿FF])
QuantifiedExpr ::= (("some" | "every") "$" VarName "in" ExprSingle ("," "$" VarName "in" ExprSingle)* "satisfies" ExprSingle)
CastExpr ::= (ArrowExpr | ("cast" "as" SingleType)?)
ReverseStep ::= ((ReverseAxis NodeTest) | AbbrevReverseStep)
MapConstructorEntry ::= (MapKeyExpr ":" MapValueExpr)
DecimalLiteral ::= (("." Digits) | (Digits "." [0-9]*))
ComparisonExpr ::= (StringConcatExpr | ((ValueComp | GeneralComp | NodeComp) StringConcatExpr)?)
Prefix ::= NCName
ForExpr ::= (SimpleForClause "return" ExprSingle)
SimpleForBinding ::= ("$" VarName "in" ExprSingle)
SimpleLetBinding ::= ("$" VarName ":=" ExprSingle)
OrExpr ::= (AndExpr | ("or" AndExpr)*)
ArrowExpr ::= (UnaryExpr | ("=>" ArrowFunctionSpecifier ArgumentList)*)
SimpleMapExpr ::= (PathExpr ("!" PathExpr)*)
Predicate ::= ("[" Expr "]")
SquareArrayConstructor ::= ("[" (ExprSingle ("," ExprSingle)*)? "]")
UnprefixedName ::= LocalPart
UnaryExpr ::= (("-" | "+")* | ValueExpr)
Lookup ::= ("?" KeySpecifier)
EQName ::= (QName | URIQualifiedName)
Digits ::= [0-9]+
StringConcatExpr ::= (RangeExpr | ("||" RangeExpr)*)
MultiplicativeExpr ::= (UnionExpr | (("*" | "div" | "idiv" | "mod") UnionExpr)*)
UnionExpr ::= (IntersectExceptExpr | (("union" | "|") IntersectExceptExpr)*)
InstanceofExpr ::= (TreatExpr | ("instance" "of" SequenceType)?)
NameChar ::= (NameStartChar | "-" | "." | [0-9] | · | [̀-ͯ] | [‿-⁀])
ForwardAxis ::= (("child" "::") | ("descendant" "::") | ("attribute" "::") | ("self" "::") | ("descendant-or-self" "::") | ("following-sibling" "::") | ("following" "::") | ("namespace" "::"))
PrimaryExpr ::= (Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall | FunctionItemExpr | MapConstructor | ArrayConstructor | UnaryLookup)
IntegerLiteral ::= Digits
Argument ::= (ExprSingle | ArgumentPlaceholder)
SimpleForClause ::= ("for" SimpleForBinding ("," SimpleForBinding)*)
StepExpr ::= (PostfixExpr | AxisStep)
AxisStep ::= ((ReverseStep | ForwardStep) PredicateList)
ArgumentPlaceholder ::= "?"
VarName ::= EQName
ArrayConstructor ::= (SquareArrayConstructor | CurlyArrayConstructor)
LocalPart ::= NCName
FunctionBody ::= EnclosedExpr
EnclosedExpr ::= ("{" EnclosedExpr? "}")
LetExpr ::= (SimpleLetClause "return" ExprSingle)
TreatExpr ::= (CastableExpr | ("treat" "as" SequenceType)?)
ForwardStep ::= ((ForwardAxis NodeTest) | AbbrevForwardStep)
ReverseAxis ::= (("parent" "::") | ("ancestor" "::") | ("preceding-sibling" "::") | ("preceding" "::") | ("ancestor-or-self" "::"))
Wildcard ::= ("*" | (NCName ":*") | ("*:" NCName) | (BracedURILiteral "*"))
NumericLiteral ::= (IntegerLiteral | DecimalLiteral | DoubleLiteral)
AdditiveExpr ::= (MultiplicativeExpr | (("+" | "-") MultiplicativeExpr)*)
CastableExpr ::= (CastExpr | ("castable" "as" SingleType)?)
FunctionCall ::= (EQName ArgumentList)
MapConstructor ::= ("map" "{" (MapConstructorEntry ("," MapConstructorEntry)*)? "}")
MapValueExpr ::= ExprSingle
EscapeQuot ::= "\"\""
Name ::= (NameStartChar NameChar*)
