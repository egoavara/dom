package grammer

import (
	"io"
	"strings"
	"fmt"
	"time"
)


const _EBNFHEADERCOMMENT =
	` /* Auto generated by grammer package
 * At %s 
*/` + "\n"

type EBNFEncoder struct {
	dst io.Writer
}

func NewEBNFEncoder(dst io.Writer) *EBNFEncoder {
	if dst == nil{
		return nil
	}
	dst.Write([]byte(fmt.Sprintf(_EBNFHEADERCOMMENT, time.Now().Format(time.RFC3339))))
	return &EBNFEncoder{
		dst:dst,
	}
}

func (s *EBNFEncoder) toExpression(expr Expression) string {
	switch e := expr.(type) {
	case *ExpressionRefer:
		return e.id
	case *ExpressionPrefix:
		return `"` + strings.Replace(e.prefix, `"`, `\"`, -1) + `"`
	case *ExpressionRegexp:
		return e.original
	case *ExpressionAnd:
		res := "("
		for _, c := range e.cond {
			res += s.toExpression(c)
			res += " "
		}
		res = res[:len(res) - 1]
		res += ")"
		return res
	case *ExpressionOr:
		res := "("
		for _, c := range e.cond {
			res += s.toExpression(c)
			res += " | "
		}
		res = res[:len(res) - 3]
		res += ")"
		return res
	case *ExpressionExcept:
		return fmt.Sprintf("%s - %s", s.toExpression(e.ori), s.toExpression(e.e))
	case *ExpressionMultiple:
		return s.toExpression(e.e)+ "*"
	case *ExpressionPossible:
		return s.toExpression(e.e)+ "?"
	}
	return ""
}
func (s *EBNFEncoder) Encode(grammer *Grammer) error {
	for k, v := range grammer.gram {
		_, err := s.dst.Write([]byte(fmt.Sprintf("%s ::= %s\n", k, s.toExpression(v))))
		if err != nil {
			return err
		}
	}
	return nil
}